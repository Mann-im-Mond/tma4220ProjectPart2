% !TeX spellcheck = en_GB 

\section{\label{sec::odesolver}Solving the ODE}

From equation (\ref{eqn::matrixForm}) we get a system of $n_D-1$ ordinary differential equation of order 1, where at most the inhomogenious part can be non-linear. So we have to solve an initial value problem (IVP) of the form
\begin{flalign*}
	M\dot{u}=Au+v(t)
\end{flalign*}
on the interval $t\in\left[t_0,t_{max}\right]$ with initial value $u_0=u(t_0)$. The ODE can of course also be written as 
\begin{flalign*}
	\dot{u}=M^{-1}(Au+v(t))
\end{flalign*}
but inverting a matrix of size $(n_D-1)\times(n_D-1)$ would take probably at least $\mathcal{O}(n_D^3)$ \cite{li2009fastsolver} operations so is something that wants to be avoided, since e.g. in our case this would be of order $>10^{12}$. \\
To solve the IVP we implemented the following four different solvers. All of them are one step solvers, meaning to compute the next time step only the timestep before is used. Two of the solvers are explicit and two implicit. The advantage of an explicit solver is normaly, that for each time step only one matrix multiplication and one vector addition would be needed. Since in our case we have to solve for $M$ at all, this will not realy help. Also explicit methods are not stable especially over a long time \cite{dahmen2006numerik}, since the matrix is expected to be stiff and having a condition number, that encreases with smaller stepwidth $h$. But baking a cake takes normaly more then 1 hour or 3600 seconds. The disadvantage of implicit methods is, that you have to invert a matrix every time step, therefor they are satble also over a long time. Finaly the methods we implemented and their iterations are
\begin{itemize}
	\item Implicit methods
	\begin{enumerate}[label=\arabic*.)]
		\item Forward Euler
		\begin{flalign*}
			u_{n+1}=u_n+hM^{-1}(Au_n+v(t_n))
		\end{flalign*}
		\item Improved Forward Euler
		\begin{flalign*}
			u_{n+1}=u_n+\frac{h}{2}M^{-1}\left(2Au_n+v(t_n)+v(t_{n+1})+hA\cdot M^{-1}\left(Au_n+v(t_n)\right)\right)
		\end{flalign*}
	\end{enumerate}
	\item Explicit methods
	\begin{enumerate}[resume,label=\arabic*.)]
		\item Backwards Euler
		\begin{flalign*}
			(M-hA)u_{n+1}=Mu_n+hv(t_n)
		\end{flalign*}
		\item Crank-Nicholson
		\begin{flalign*}
			(M-\frac{h}{2}A)u_{n+1}=(M+\frac{h}{2}A)u_n+\frac{h}{2}(v(t_n)+v(t_{n+1}))
		\end{flalign*}
	\end{enumerate}
\end{itemize}
So we have to solve a linear system in each time step for each of these methods. Instead of completly solving the system we want to do some steps of an iterative solver. The most convincing solver we found is the preconditioned conjugete gradient (PCG) method. This method is implemented in MATLAB and can called by \emph{pcg}. As preconditioner we chose modified incomplete cholesky decomposition, which is also implemented and can be called by
\begin{lstlisting}[language=matlab]
	ichol(Matrix,struct('michol','on'))
\end{lstlisting}
in MATLAB. The paper \cite{tatebe1993multigrid} compares the cholesky preconditioner with multigrid as preconditioner. Here we see, that solving a huge matrix is faster using multigrid as preconditioner. But for our case, where the matrix is large but not huge, doing a few steps with cholesky as preconditioner takes around the same time.
